## Запуск

```
node src/index.js <input file> [optional output file]
```

## Пример

```
node src/index.js test/data/input.json
node src/index.js test/data/input.json test-output.json
```

## Запуск тестов

```
npm test
```

## Ход мыслей

Прежде, чем приступить к написанию решения 3-го задания я его тчательно обдумала: выписала основные данные,
визуализировала их в виде часов, радиусом которых являлась максимальная мощность и разместила девайсы в соответсткующие периоды так,
чтобы они занимали промежуток, равный их мощности.
![alt text](github.com/preigile/algorithm/idea.jpg "Визуализированные данные")

Первой идеей было разделить девайсы на режимы (дневной/ночной) и отсортировать по затраченной работе (мощности помноженной на время).
Затем я бы помещала девайсы в соответствующие ячейки с учётом того, что в ней достаточно места для конкретного девайса.
Вероятно, этот вариант не плохо работал бы, но не был бы самым оптимальным.

В процессе размышлений алгоритм постоянно менялся и в итоге я пришла к выводу, что,
чтобы отыскать самую выгодную для пользователя компоновку девайсов, не обойтись без перебора всех возможных вариантов и метода ветвений и границ.
Да, это немного более долгая процедура, чем, например, в первом случае, но мы гарантированно найдём один из самых лучших вариантов.

Чтобы оптимизировать процесс и увеличить скорость подсчёта использовала ряд улучшений:
- все девайсы с временем работы 24 часа сразу помещаются в массив с девайсами;
- проверка на превышение maxpower в данный час до построения очередного полного расписания;
- стоимость всего расписания рассчитывается на каждом шаге и мы не идём глубже, если она выше текущего найденного минимума.
